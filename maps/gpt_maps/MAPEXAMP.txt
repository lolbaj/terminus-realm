def generate_overworld(self, seed: Optional[int] = None):
    """
    Generate a large overworld-style map with biomes.
    Designed for very large maps (e.g. 500x500).
    """
    if seed is not None:
        np.random.seed(seed)

    h, w = self.height, self.width

    # Start with grass everywhere
    self.tiles[:, :] = TILE_GRASS

    # --- WATER ---
    for _ in range(120):
        cx = np.random.randint(0, w)
        cy = np.random.randint(0, h)
        radius = np.random.randint(8, 30)

        for y in range(max(0, cy - radius), min(h, cy + radius)):
            for x in range(max(0, cx - radius), min(w, cx + radius)):
                if (x - cx) ** 2 + (y - cy) ** 2 < radius ** 2:
                    self.tiles[y, x] = TILE_WATER

    # --- SAND (around water) ---
    for y in range(1, h - 1):
        for x in range(1, w - 1):
            if self.tiles[y, x] == TILE_GRASS:
                neighbors = self.tiles[y - 1 : y + 2, x - 1 : x + 2]
                if TILE_WATER in neighbors:
                    self.tiles[y, x] = TILE_SAND

    # --- FORESTS ---
    for _ in range(200):
        cx = np.random.randint(0, w)
        cy = np.random.randint(0, h)
        radius = np.random.randint(6, 20)

        for y in range(max(0, cy - radius), min(h, cy + radius)):
            for x in range(max(0, cx - radius), min(w, cx + radius)):
                if self.tiles[y, x] == TILE_GRASS:
                    if (x - cx) ** 2 + (y - cy) ** 2 < radius ** 2:
                        self.tiles[y, x] = TILE_TREE


#part 2

# --- CLIMATE ZONES (Latitude-based) ---
    for y in range(h):
        climate = y / h  # 0.0 = north, 1.0 = south

        for x in range(w):
            tile = self.tiles[y, x]

            # â„ï¸ SNOW ZONE (North)
            if climate < 0.18:
                if tile == TILE_GRASS:
                    self.tiles[y, x] = TILE_SNOW
                elif tile == TILE_WATER:
                    self.tiles[y, x] = TILE_ICE

            # ðŸŒµ DESERT ZONE (South-mid)
            elif climate > 0.65 and climate < 0.85:
                if tile == TILE_GRASS:
                    self.tiles[y, x] = TILE_SAND
                if np.random.rand() < 0.02:
                    self.tiles[y, x] = TILE_CACTUS

            # ðŸŒ‹ LAVA ZONE (Far South)
            elif climate >= 0.85:
                if tile in (TILE_GRASS, TILE_SAND):
                    self.tiles[y, x] = TILE_ASH
                if np.random.rand() < 0.05:
                    self.tiles[y, x] = TILE_LAVA

#part3

def carve_road(self, x1: int, y1: int, x2: int, y2: int):
    """Create a simple L-shaped road."""
    for x in range(min(x1, x2), max(x1, x2) + 1):
        if self.tiles[y1, x] not in (TILE_WATER, TILE_LAVA):
            self.tiles[y1, x] = TILE_PAVEMENT

    for y in range(min(y1, y2), max(y1, y2) + 1):
        if self.tiles[y, x2] not in (TILE_WATER, TILE_LAVA):
            self.tiles[y, x2] = TILE_PAVEMENT
def generate_towns(self, town_count: int = 8):
    """Place towns across valid terrain."""
    towns = []

    for _ in range(town_count):
        for _ in range(50):  # retry attempts
            x = np.random.randint(20, self.width - 20)
            y = np.random.randint(20, self.height - 20)

            # Avoid bad biomes
            if self.tiles[y, x] in (
                TILE_WATER,
                TILE_LAVA,
                TILE_ICE,
                TILE_ASH,
            ):
                continue

            size = np.random.randint(6, 10)

            # Pavement core
            for dy in range(-size, size + 1):
                for dx in range(-size, size + 1):
                    self.tiles[y + dy, x + dx] = TILE_PAVEMENT

            # Simple buildings
            for _ in range(4):
                bx = x + np.random.randint(-size + 2, size - 2)
                by = y + np.random.randint(-size + 2, size - 2)

                # Walls
                for i in range(-2, 3):
                    self.tiles[by - 2, bx + i] = TILE_WALL
                    self.tiles[by + 2, bx + i] = TILE_WALL
                    self.tiles[by + i, bx - 2] = TILE_WALL
                    self.tiles[by + i, bx + 2] = TILE_WALL

                # Floor
                for iy in range(-1, 2):
                    for ix in range(-1, 2):
                        self.tiles[by + iy, bx + ix] = TILE_FLOOR

                # Door
                self.tiles[by + 2, bx] = TILE_DOOR

            towns.append((x, y))
            break

    # Connect towns with roads
    for i in range(1, len(towns)):
        self.carve_road(
            towns[i - 1][0],
            towns[i - 1][1],
            towns[i][0],
            towns[i][1],
        )

    return towns

#part4

def get_camera_bounds(
    player_x: int,
    player_y: int,
    map_width: int,
    map_height: int,
    view_width: int,
    view_height: int,
):
    half_w = view_width // 2
    half_h = view_height // 2

    cam_x = max(0, min(player_x - half_w, map_width - view_width))
    cam_y = max(0, min(player_y - half_h, map_height - view_height))

    return cam_x, cam_y

def render_viewport(
    self,
    cam_x: int,
    cam_y: int,
    view_width: int,
    view_height: int,
):
    """
    Yield tiles for rendering inside a viewport.
    """
    for y in range(cam_y, cam_y + view_height):
        row = []
        for x in range(cam_x, cam_x + view_width):
            visible = self.visible[y, x]
            char = self.get_tile_char(x, y, visible)
            fg = self.get_tile_fg_color(x, y, visible)
            row.append((char, fg))
        yield row

#part 5

self.stairs_down_links = {}  # (x, y) -> dungeon_id
self.stairs_up_links = {}    # (x, y) -> (overworld_x, overworld_y)

def generate_dungeon_entrances(self, count: int = 12):
    dungeon_entries = []

    for dungeon_id in range(count):
        for _ in range(100):
            x = np.random.randint(10, self.width - 10)
            y = np.random.randint(10, self.height - 10)

            if self.tiles[y, x] in (
                TILE_GRASS,
                TILE_SAND,
                TILE_SNOW,
                TILE_ASH,
            ):
                self.tiles[y, x] = TILE_STAIRS_DOWN
                self.stairs_down_links[(x, y)] = dungeon_id
                dungeon_entries.append((x, y, dungeon_id))
                break

    return dungeon_entries

def create_dungeon_map(
    width: int = 60,
    height: int = 60,
    entrance_x: int = 30,
    entrance_y: int = 30,
):
    dungeon = GameMap(width, height)
    rooms, start = dungeon.generate_dungeon_rooms(
        max_rooms=15, min_size=5, max_size=10
    )

    sx, sy = start
    dungeon.tiles[sy, sx] = TILE_STAIRS_UP
    dungeon.stairs_up_links[(sx, sy)] = (entrance_x, entrance_y)

    return dungeon

# Overworld
world = GameMap(500, 500)
world.generate_overworld(seed=42)
world.generate_towns()
entrances = world.generate_dungeon_entrances()

# Dungeons
dungeons = {}
for x, y, dungeon_id in entrances:
    dungeons[dungeon_id] = create_dungeon_map(
        entrance_x=x,
        entrance_y=y,
    )

def get_biome(tile_type: int) -> str:
    if tile_type == TILE_GRASS:
        return "plains"
    if tile_type == TILE_TREE:
        return "forest"
    if tile_type in (TILE_SNOW, TILE_ICE):
        return "tundra"
    if tile_type in (TILE_SAND, TILE_CACTUS):
        return "desert"
    if tile_type in (TILE_LAVA, TILE_ASH):
        return "volcanic"
    if tile_type == TILE_FLOOR:
        return "dungeon"
    return "neutral"

SPAWN_TABLE = {
    "plains": ["slime", "rat"],
    "forest": ["wolf", "goblin"],
    "tundra": ["ice_slime", "snow_wolf"],
    "desert": ["scorpion", "mummy"],
    "volcanic": ["fire_imp", "lava_golem"],
    "dungeon": ["skeleton", "bat"],
}

def spawn_entities_by_biome(self, entity_manager, spawn_chance: float = 0.01):
    for y in range(self.height):
        for x in range(self.width):
            if not self.is_walkable(x, y):
                continue

            if np.random.rand() > spawn_chance:
                continue

            biome = get_biome(self.tiles[y, x])
            enemies = SPAWN_TABLE.get(biome)

            if enemies:
                enemy_type = np.random.choice(enemies)
                entity_manager.spawn(enemy_type, x, y)
